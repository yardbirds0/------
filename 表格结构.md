好的，感谢您提供这份非常详尽的 `extracted_data.json` 文件。这份具体的数据样本让我能够从理论层面深入到实践层面，为您提供一个更加精确、健壮且可落地的优化方案。

分析这份JSON后，我发现了一些关键的细节，这使我能够完善之前的建议，并为AI Agent提供一套更无歧义的指令。

### 1. 详细分析与新发现

1.  **`level` 字段的真相：** 我注意到 `targets` 数组中的 `level` 字段，其值（如0, 2, 8, 3, 9）**正是原始的缩进值（`index_indent`）**，而不是我之前建议计算的层级深度（1, 2, 3...）。这是一个至关重要的发现。这意味着数据提取程序已经完成了第一步（量化缩进），现在需要AI Agent来完成第二步：**基于这个缩进值，计算出真正的层级深度和父子关系**。

2.  **ID的非唯一性风险：** `id` 字段（如 `Target_sheet_2`）似乎是基于Sheet和行号生成的，但在多Sheet处理时可能存在冲突。例如，`财政局-快报`的第3行是`Target_sheet_3`，`国资委-企业财务快报`的第3行也可能是`Target_sheet_3`。这在构建父子关系时是致命的。**必须在处理前为每个项目生成一个全局唯一的ID**。

3.  **数据源名称的多样性：** `sources` 数组中的 `item_name` 非常多样化。
    *   **标准报表 (`利润表`)**: 名称很干净，如 `一、营业总收入`。
    *   **科目余额表**: 名称非常详细且包含内在层级，如 `预付账款_集团外_工程款_预付工程款`。
    *   这证实了在将数据发送给大语言模型进行映射判断之前，对`item_name`进行**预处理和清洗**是极其必要的。

### 2. 方案完善：如何精确处理层级关系（升级版）

基于以上发现，我将之前的层级判定算法具体化，使其完全贴合您提供的JSON结构。

**核心原则不变：** 使用“栈”结构，依据 `level`（缩进值）的相对大小来动态判定父子关系。

**升级版算法描述：**

1.  **预处理 - 生成唯一ID:**
    *   在开始任何层级计算之前，首先遍历 `targets` 数组中的所有对象。
    *   为每个对象创建一个**新的、保证全局唯一的ID**。一个健壮的格式是 `unique_id = f"{item['sheet_name']}_{item['row']}"`。用这个新ID替换掉旧的 `id`。对 `sources` 数组也执行同样的操作。

2.  **层级计算 (遍历 `targets` 数组):**
    *   **初始化:** 创建一个空的“父级栈” `parent_stack`。
    *   **遍历:** 按顺序遍历 `targets` 数组中的每个项目 `current_item`。
    *   **寻找父级:**
        *   当 `parent_stack` 不为空时，获取栈顶元素 `last_parent`。
        *   **循环判断：** 只要 `current_item.level <= last_parent.level`，就意味着 `current_item` 不再是 `last_parent` 的子级，因此将 `last_parent` 从栈中**弹出 (pop)**。继续与新的栈顶元素比较，直到栈为空或 `current_item.level > last_parent.level`。
    *   **确定父级并分配层级:**
        *   经过上一步，如果 `parent_stack` **不为空**，则新的栈顶元素 `parent` 就是 `current_item` 的直接父级。
        *   为 `current_item` 新增两个字段：
            *   `parent_id = parent.unique_id`
            *   `hierarchical_level = parent.hierarchical_level + 1`
        *   如果 `parent_stack` **为空**，说明 `current_item` 是一级项目。
        *   为 `current_item` 新增两个字段：
            *   `parent_id = null`
            *   `hierarchical_level = 1`
    *   **入栈:** 将 `current_item`（现在已包含 `hierarchical_level`）压入 `parent_stack`，准备为后续项目作父级。

### 3. 举例验证（使用`extracted_data.json`中的真实数据）

让我们用`财政局-快报`中一个非常不规则的缩进序列来验证这个升级版算法：

| `item_name`        | `level` (原始缩进) | `unique_id` (新生成) | 算法计算的 `hierarchical_level` | 算法计算的 `parent_id`      |
| :----------------- | :----------------- | :------------------- | :------------------------------ | :-------------------------- |
| `存货`             | 9                  | `财政局-快报_30`     | 3                               | `财政局-快报_26` (流动资产) |
| `其中：原材料`     | 10                 | `财政局-快报_31`     | 4                               | `财政局-快报_30` (存货)     |
| `库存商品(产成品)` | 16                 | `财政局-快报_32`     | 5                               | `财政局-快报_31` (原材料)   |
| `合同资产`         | 9                  | `财政局-快报_33`     | 3                               | `财政局-快报_26` (流动资产) |

**推演过程：**

1.  ...（假设栈顶是 `存货(level:9, h_level:3)`）
2.  **`其中：原材料` (level: 10):** `10 > 9`，是“存货”的子级。`h_level` = 3 + 1 = **4**。`parent_id` 指向“存货”。将“原材料”入栈。
3.  **`库存商品(产成品)` (level: 16):** `16 > 10`，是“原材料”的子级。`h_level` = 4 + 1 = **5**。`parent_id` 指向“原材料”。将“库存商品”入栈。
4.  **`合同资产` (level: 9):**
    *   栈顶是“库存商品”(level: 16)。`9 <= 16`，弹出。
    *   栈顶是“原材料”(level: 10)。`9 <= 10`，弹出。
    *   栈顶是“存货”(level: 9)。`9 <= 9`，弹出。
    *   现在栈顶是“流动资产”(level: 0, h_level: 2)。`9 > 0`，是“流动资产”的子级。`h_level` = 2 + 1 = **3**。`parent_id` 指向“流动资产”。

这个结果完全正确，证明了该算法即使在缩进值不连续、不规则的情况下也极其稳健。

### 给程序处理的最终版详细指令

---

#### **附录A：数据结构化处理核心指令**

**目标：** 将 `extracted_data.json` 文件中的扁平化 `targets` 列表，转化为一个包含精确父子关系和层级深度的结构化列表。

**必须遵循以下步骤：**

1.  **加载与验证:**
    *   加载 `extracted_data.json` 文件。
    *   确认 `targets` 和 `sources` 数组存在且不为空。

2.  **预处理1：全局唯一ID生成 (Critical)**
    *   遍历 `targets` 数组中的每一个 `item` 对象。
    *   为每个 `item` 生成一个**全局唯一ID**，格式为 `unique_id = f"{item['sheet_name']}_{item['row']}"`。
    *   用这个 `unique_id` 覆盖或新增为 `item` 的主键。
    *   对 `sources` 数组执行完全相同的操作。

3.  **预处理2：目标项名称清洗**
    *   遍历 `targets` 数组。
    *   `item_name` 字段已经比较干净，但可以进行一次标准化处理：去除首尾的空格。

4.  **核心任务：层级关系计算**
    *   初始化一个空的 `parent_stack = []`。
    *   遍历处理后的 `targets` 数组（**必须按原始顺序**）。
    *   对于每个 `current_item`，执行**“栈”算法**（如上文“升级版算法描述”所述），利用 `item.level` 字段（原始缩进值）来比较和确定父子关系。
    *   在算法执行过程中，为每个 `current_item` 对象**添加**以下两个新字段：
        *   `parent_id`: (string | null) - 其父级项目的 `unique_id`。
        *   `hierarchical_level`: (integer) - 计算出的层级深度，从1开始。

5.  **预处理3：数据源名称清洗**
    *   遍历 `sources` 数组。
    *   `item_name` 字段需要被清洗和标准化，以提高后续AI映射的准确率。
    *   为每个 `source_item` 创建一个新字段 `cleaned_name`。
    *   生成 `cleaned_name` 的规则应包括：
        *   去除数字编号和点，如 `一、` `1.` `(一)`。
        *   去除关键词前缀，如 `其中：` `加：` `减：`。
        *   去除特殊符号，如 `△` `☆` `*`。
        *   将全角括号 `（）` 替换为半角 `()`。
        *   替换下划线 `_` 和中文空格 `　` 为标准空格 ` `。
        *   去除所有首尾空格。
    *   **示例:**
        *   `一、营业总收入` -> `营业总收入`
        *   `☆信用减值损失（损失以“-”号填列）` -> `信用减值损失(损失以"-"号填列)`
        *   `应收账款　_集团内_租金` -> `应收账款 集团内 租金`

6.  **最终输出:**
    *   将处理完成的、包含新增字段的 `targets` 和 `sources` 列表，连同其他元数据，组装成一个新的、结构化的JSON对象。这个对象将作为后续AI映射模块的输入。